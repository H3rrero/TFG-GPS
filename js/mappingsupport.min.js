cR.prototype = new google.maps.OverlayView; function cR(ez) { this.setValues(ez); dL.label_span = this.span_ = document.createElement('span'); dL.label_span.style.cssText = dL.fo; dL.label_div = this.div_ = document.createElement('div'); dL.label_div.appendChild(dL.label_span); dL.label_div.style.cssText = 'position: absolute; display: none'; }; cR.prototype.onAdd = function () { var ew = this.getPanes().overlayImage; ew.appendChild(this.div_); }; cR.prototype.onRemove = function () { this.div_.parentNode.removeChild(this.div_); }; cR.prototype.draw = function () { dL.label_projection = this.getProjection(); dL.label_position = dL.label_projection.fromLatLngToDivPixel(this.get('position')); dL.label_div = this.div_; dL.label_div.style.left = dL.label_position.x + 'px'; dL.label_div.style.top = dL.label_position.y + 'px'; dL.label_div.style.display = 'block'; this.span_.innerHTML = this.get('text'); }; cR.prototype.gJ = function () { if (this.div_) { this.div_.style.visibility = "hidden"; } }; cR.prototype.hH = function () { if (this.div_) { this.div_.style.visibility = "visible"; } }; cR.prototype.fv = function () { if (this.div_) { this.span_.style.cssText = dL.fo; } }; var aQ = 3.14159265358979; var aE = 6378137.0; var aC = 6356752.314; var aZ = 6.69437999013e-03; var bk = 0.9996; function gz(ac, bG, bd) { var bc = new Array(3); aq = ac.toUrlValue(); aK = aq.split(","); lat = aK[0]; lon = aK[1]; lon = parseFloat(lon); lat = parseFloat(lat); if (bd == "null") { if (bG == "center") { aq = dL.map.getCenter(); aq = aq.lng().toFixed(6); aq = parseFloat(aq); bd = Math.floor((aq + 180.0) / 6) + 1; } else { bd = Math.floor((lon + 180.0) / 6) + 1; } } bc[2] = bd; bd = rg(lL(lat), lL(lon), bd, bc); return (bc); }; function gA(bI, bL, bH, aY) { ad = new Array(2); var x, y, bd, aI; x = bI; y = bL; bd = bH; aI = aY; qp(x, y, bd, aI, ad); ad[0] = nM(ad[0]); ad[1] = nM(ad[1]); return (ad); }; function lL(da) { return (da / 180.0 * aQ) }; function nM(aV) { return (aV / aQ * 180.0) }; function qR(aw) { var alpha, beta, U, aa, V, n; var result; n = (aE - aC) / (aE + aC); alpha = ((aE + aC) / 2.0) * (1.0 + (Math.pow(n, 2.0) / 4.0) + (Math.pow(n, 4.0) / 64.0)); beta = (-3.0 * n / 2.0) + (9.0 * Math.pow(n, 3.0) / 16.0) + (-3.0 * Math.pow(n, 5.0) / 32.0); U = (15.0 * Math.pow(n, 2.0) / 16.0) + (-15.0 * Math.pow(n, 4.0) / 32.0); aa = (-35.0 * Math.pow(n, 3.0) / 48.0) + (105.0 * Math.pow(n, 5.0) / 256.0); V = (315.0 * Math.pow(n, 4.0) / 512.0); result = alpha * (aw + (beta * Math.sin(2.0 * aw)) + (U * Math.sin(4.0 * aw)) + (aa * Math.sin(6.0 * aw)) + (V * Math.sin(8.0 * aw))); return result; }; function pn(bd) { var O; O = lL(-183.0 + (bd * 6.0)); return O; }; function pz(y) { var be, G, beta_FootpointLatitude, am, nn, qw, n; var result; n = (aE - aC) / (aE + aC); G = ((aE + aC) / 2.0) * (1 + (Math.pow(n, 2.0) / 4) + (Math.pow(n, 4.0) / 64)); be = y / G; beta_FootpointLatitude = (3.0 * n / 2.0) + (-27.0 * Math.pow(n, 3.0) / 32.0) + (269.0 * Math.pow(n, 5.0) / 512.0); am = (21.0 * Math.pow(n, 2.0) / 16.0) + (-55.0 * Math.pow(n, 4.0) / 32.0); nn = (151.0 * Math.pow(n, 3.0) / 96.0) + (-417.0 * Math.pow(n, 5.0) / 128.0); qw = (1097.0 * Math.pow(n, 4.0) / 512.0); result = be + (beta_FootpointLatitude * Math.sin(2.0 * be)) + (am * Math.sin(4.0 * be)) + (nn * Math.sin(6.0 * be)) + (qw * Math.sin(8.0 * be)); return result; }; function qD(aw, ap, ah, bc) { var N, aG, lu, t, t2, l; var al, ak, ao, an, aj, ai; var aX; lu = (Math.pow(aE, 2.0) - Math.pow(aC, 2.0)) / Math.pow(aC, 2.0); aG = lu * Math.pow(Math.cos(aw), 2.0); N = Math.pow(aE, 2.0) / (aC * Math.sqrt(1 + aG)); t = Math.tan(aw); t2 = t * t; aX = (t2 * t2 * t2) - Math.pow(t, 6.0); l = ap - ah; al = 1.0 - t2 + aG; ak = 5.0 - t2 + 9 * aG + 4.0 * (aG * aG); ao = 5.0 - 18.0 * t2 + (t2 * t2) + 14.0 * aG - 58.0 * t2 * aG; an = 61.0 - 58.0 * t2 + (t2 * t2) + 270.0 * aG - 330.0 * t2 * aG; aj = 61.0 - 479.0 * t2 + 179.0 * (t2 * t2) - (t2 * t2 * t2); ai = 1385.0 - 3111.0 * t2 + 543.0 * (t2 * t2) - (t2 * t2 * t2); bc[0] = N * Math.cos(aw) * l + (N / 6.0 * Math.pow(Math.cos(aw), 3.0) * al * Math.pow(l, 3.0)) + (N / 120.0 * Math.pow(Math.cos(aw), 5.0) * ao * Math.pow(l, 5.0)) + (N / 5040.0 * Math.pow(Math.cos(aw), 7.0) * aj * Math.pow(l, 7.0)); bc[1] = qR(aw) + (t / 2.0 * N * Math.pow(Math.cos(aw), 2.0) * Math.pow(l, 2.0)) + (t / 24.0 * N * Math.pow(Math.cos(aw), 4.0) * ak * Math.pow(l, 4.0)) + (t / 720.0 * N * Math.pow(Math.cos(aw), 6.0) * an * Math.pow(l, 6.0)) + (t / 40320.0 * N * Math.pow(Math.cos(aw), 8.0) * ai * Math.pow(l, 8.0)); return; }; function qr(x, y, ah, aT) { var aO, aH, ay, aA, lu, aL, az, aM, L; var bv, bw, bC, bz, bo, bm, bt, bq; var bB, bA, bn, bl, bp, bu, bs; aO = pz(y); lu = (Math.pow(aE, 2.0) - Math.pow(aC, 2.0)) / Math.pow(aC, 2.0); L = Math.cos(aO); aA = lu * Math.pow(L, 2.0); aH = Math.pow(aE, 2.0) / (aC * Math.sqrt(1 + aA)); ay = aH; aL = Math.tan(aO); az = aL * aL; aM = az * az; bv = 1.0 / (ay * L); ay *= aH; bw = aL / (2.0 * ay); ay *= aH; bC = 1.0 / (6.0 * ay * L); ay *= aH; bz = aL / (24.0 * ay); ay *= aH; bo = 1.0 / (120.0 * ay * L); ay *= aH; bm = aL / (720.0 * ay); ay *= aH; bt = 1.0 / (5040.0 * ay * L); ay *= aH; bq = aL / (40320.0 * ay); bB = -1.0 - aA; bA = -1.0 - 2 * az - aA; bn = 5.0 + 3.0 * az + 6.0 * aA - 6.0 * az * aA - 3.0 * (aA * aA) - 9.0 * az * (aA * aA); bl = 5.0 + 28.0 * az + 24.0 * aM + 6.0 * aA + 8.0 * az * aA; bp = -61.0 - 90.0 * az - 45.0 * aM - 107.0 * aA + 162.0 * az * aA; bu = -61.0 - 662.0 * az - 1320.0 * aM - 720.0 * (aM * az); bs = 1385.0 + 3633.0 * az + 4095.0 * aM + 1575 * (aM * az); aT[0] = aO + bw * bB * (x * x) + bz * bn * Math.pow(x, 4.0) + bm * bp * Math.pow(x, 6.0) + bq * bs * Math.pow(x, 8.0); aT[1] = ah + bv * x + bC * bA * Math.pow(x, 3.0) + bo * bl * Math.pow(x, 5.0) + bt * bu * Math.pow(x, 7.0); return; }; function rg(lat, lon, bd, bc) { qD(lat, lon, pn(bd), bc); bc[0] = bc[0] * bk + 500000.0; bc[1] = bc[1] * bk; if (bc[1] < 0.0) bc[1] = bc[1] + 10000000.0; return bd; }; function qp(x, y, bd, aI, ad) { var O; x -= 500000.0; x /= bk; if (aI) y -= 10000000.0; y /= bk; O = pn(bd); qr(x, y, O, ad); return; }; function tS(value, sq, opt_max) { if (sq != null) value = Math.max(value, sq); if (opt_max != null) value = Math.min(value, opt_max); return value; }; function tQ(deg) { return deg * (Math.PI / 180); }; function uc(aV) { return aV / (Math.PI / 180); }; function of() { this.pixelOrigin_ = new google.maps.Point(dL.kN / 2, dL.kN / 2); this.pixelsPerLonDegree_ = dL.kN / 360; this.pixelsPerLonRadian_ = dL.kN / (2 * Math.PI); }; of.prototype.fromLatLngToPoint = function (latLng, tY) { var me = this; dL.oL = tY || new google.maps.Point(0, 0); dL.kV = me.pixelOrigin_; dL.oL.x = dL.kV.x + latLng.lng() * me.pixelsPerLonDegree_; dL.rI = tS(Math.sin(tQ(latLng.lat())), -0.9999, 0.9999); dL.oL.y = dL.kV.y + 0.5 * Math.log((1 + dL.rI) / (1 - dL.rI)) * -me.pixelsPerLonRadian_; return dL.oL; }; of.prototype.fromPointToLatLng = function (point) { var me = this; dL.kV = me.pixelOrigin_; dL.tH = (point.x - dL.kV.x) / me.pixelsPerLonDegree_; dL.uY = (point.y - dL.kV.y) / -me.pixelsPerLonRadian_; dL.uS = uc(2 * Math.atan(Math.exp(dL.uY)) - Math.PI / 2); return new google.maps.LatLng(dL.uS, dL.tH); }; function nr(point, zoom) { dL.mg = 1 << zoom; dL.qe = dL.rE.fromLatLngToPoint(point); dL.hJ = new google.maps.Point(dL.qe.x * dL.mg, dL.qe.y * dL.mg); dL.hJ.x = Math.round(dL.hJ.x); dL.hJ.y = Math.round(dL.hJ.y); }; function mV(yd, xS) { dL.xD = yd / dL.mg; dL.yF = xS / dL.mg; dL.xB = new google.maps.Point(dL.xD, dL.yF); dL.dP = dL.rE.fromPointToLatLng(dL.xB); dL.zA = dL.dP.lat().toFixed(6); dL.zk = dL.dP.lng().toFixed(6); }; var ngFunctionsPresent = true; var UNDEFINED_STR = "undefined"; var UTMEasting; var UTMNorthing; var UTMZone; var zoneNumber; var FOURTHPI = Math.PI / 4; var DEG_2_RAD = Math.PI / 180; var RAD_2_DEG = 180.0 / Math.PI; var BLOCK_SIZE = 100000; var IS_NAD83_DATUM = true; var GRIDSQUARE_SET_COL_SIZE = 8; var GRIDSQUARE_SET_ROW_SIZE = 20; var EASTING_OFFSET = 500000.0; var NORTHING_OFFSET = 10000000.0; var k0 = 0.9996; var EQUATORIAL_RADIUS; var ECCENTRICTY_SQUARED; var ECC_PRIME_SQUARED; if (IS_NAD83_DATUM) { EQUATORIAL_RADIUS = 6378137.0; ECC_SQUARED = 0.006694380023; } else { EQUATORIAL_RADIUS = 6378206.4; ECC_SQUARED = 0.006768658; } var ECC_PRIME_SQUARED = ECC_SQUARED / (1 - ECC_SQUARED); var E1 = (1 - Math.sqrt(1 - ECC_SQUARED)) / (1 + Math.sqrt(1 - ECC_SQUARED)); function getZoneNumber(lat, lon) { lat = parseFloat(lat); lon = parseFloat(lon); if (lon > 360 || lon < -180 || lat > 84 || lat < -80) { Console.log('usng.js, getZoneNumber: invalid input. lat: ' + lat.toFixed(4) + ' lon: ' + lon.toFixed(4) + "  From USNG conversion code."); } var lonTemp = (lon + 180) - parseInt((lon + 180) / 360) * 360 - 180; var zoneNumber = parseInt((lonTemp + 180) / 6) + 1; if (lat >= 56.0 && lat < 64.0 && lonTemp >= 3.0 && lonTemp < 12.0) { zoneNumber = 32; } if (lat >= 72.0 && lat < 84.0) { if (lonTemp >= 0.0 && lonTemp < 9.0) { zoneNumber = 31; } else if (lonTemp >= 9.0 && lonTemp < 21.0) { zoneNumber = 33; } else if (lonTemp >= 21.0 && lonTemp < 33.0) { zoneNumber = 35; } else if (lonTemp >= 33.0 && lonTemp < 42.0) { zoneNumber = 37; } } return zoneNumber; }; function LLtoUTM(lat, lon, utmcoords, bd) { lat = parseFloat(lat); lon = parseFloat(lon); if (lat > 84.0 || lat < -80.0) { return (UNDEFINED_STR); } if (lon > 360 || lon < -180 || lat > 90 || lat < -90) { Console.log('usng.js, LLtoUTM, invalid input. lat: ' + lat.toFixed(4) + ' lon: ' + lon.toFixed(4) + "  From USNG conversion code."); } lonTemp = (lon + 180) - parseInt((lon + 180) / 360) * 360 - 180; latRad = lat * DEG_2_RAD; lonRad = lonTemp * DEG_2_RAD; if (!bd) { zoneNumber = getZoneNumber(lat, lon); } else { zoneNumber = bd } lonOrigin = (zoneNumber - 1) * 6 - 180 + 3; lonOriginRad = lonOrigin * DEG_2_RAD; UTMZone = zoneNumber + "" + UTMLetterDesignator(lat) + " "; N = EQUATORIAL_RADIUS / Math.sqrt(1 - ECC_SQUARED * Math.sin(latRad) * Math.sin(latRad)); T = Math.tan(latRad) * Math.tan(latRad); C = ECC_PRIME_SQUARED * Math.cos(latRad) * Math.cos(latRad); A = Math.cos(latRad) * (lonRad - lonOriginRad); M = EQUATORIAL_RADIUS * ((1 - ECC_SQUARED / 4 - 3 * (ECC_SQUARED * ECC_SQUARED) / 64 - 5 * (ECC_SQUARED * ECC_SQUARED * ECC_SQUARED) / 256) * latRad - (3 * ECC_SQUARED / 8 + 3 * ECC_SQUARED * ECC_SQUARED / 32 + 45 * ECC_SQUARED * ECC_SQUARED * ECC_SQUARED / 1024) * Math.sin(2 * latRad) + (15 * ECC_SQUARED * ECC_SQUARED / 256 + 45 * ECC_SQUARED * ECC_SQUARED * ECC_SQUARED / 1024) * Math.sin(4 * latRad) - (35 * ECC_SQUARED * ECC_SQUARED * ECC_SQUARED / 3072) * Math.sin(6 * latRad)); UTMEasting = (k0 * N * (A + (1 - T + C) * (A * A * A) / 6 + (5 - 18 * T + T * T + 72 * C - 58 * ECC_PRIME_SQUARED) * (A * A * A * A * A) / 120) + EASTING_OFFSET); UTMNorthing = (k0 * (M + N * Math.tan(latRad) * ((A * A) / 2 + (5 - T + 9 * C + 4 * C * C) * (A * A * A * A) / 24 + (61 - 58 * T + T * T + 600 * C - 330 * ECC_PRIME_SQUARED) * (A * A * A * A * A * A) / 720))); utmcoords[0] = UTMEasting; utmcoords[1] = UTMNorthing; utmcoords[2] = zoneNumber; }; function LLtoUSNG() { lat = dL.lat; lon = dL.lng; precision = 4; if (lon < -180) { lon += 360; } else if (lon > 180) { lon -= 360; } lat = parseFloat(lat); lon = parseFloat(lon); var coords = []; LLtoUTM(lat, lon, coords); var UTMEasting = coords[0]; var UTMNorthing = coords[1]; if (lat < 0) { UTMNorthing += NORTHING_OFFSET; } USNGLetters = findGridLetters(zoneNumber, UTMNorthing, UTMEasting); USNGNorthing = Math.round(UTMNorthing) % BLOCK_SIZE; USNGEasting = Math.round(UTMEasting) % BLOCK_SIZE; USNGNorthing = Math.floor(USNGNorthing / Math.pow(10, (5 - precision))); USNGEasting = Math.floor(USNGEasting / Math.pow(10, (5 - precision))); USNG = getZoneNumber(lat, lon) + UTMLetterDesignator(lat) + " " + USNGLetters + " "; for (i_ix = String(USNGEasting).length; i_ix < precision; i_ix++) { USNG += "0"; } USNG += USNGEasting + " "; for (i_ix = String(USNGNorthing).length; i_ix < precision; i_ix++) { USNG += "0"; } USNG += USNGNorthing; return (USNG); }; function UTMLetterDesignator(lat) { lat = parseFloat(lat); if ((84 >= lat) && (lat >= 72)) letterDesignator = 'X'; else if ((72 > lat) && (lat >= 64)) letterDesignator = 'W'; else if ((64 > lat) && (lat >= 56)) letterDesignator = 'V'; else if ((56 > lat) && (lat >= 48)) letterDesignator = 'U'; else if ((48 > lat) && (lat >= 40)) letterDesignator = 'T'; else if ((40 > lat) && (lat >= 32)) letterDesignator = 'S'; else if ((32 > lat) && (lat >= 24)) letterDesignator = 'R'; else if ((24 > lat) && (lat >= 16)) letterDesignator = 'Q'; else if ((16 > lat) && (lat >= 8)) letterDesignator = 'P'; else if ((8 > lat) && (lat >= 0)) letterDesignator = 'N'; else if ((0 > lat) && (lat >= -8)) letterDesignator = 'M'; else if ((-8 > lat) && (lat >= -16)) letterDesignator = 'L'; else if ((-16 > lat) && (lat >= -24)) letterDesignator = 'K'; else if ((-24 > lat) && (lat >= -32)) letterDesignator = 'J'; else if ((-32 > lat) && (lat >= -40)) letterDesignator = 'H'; else if ((-40 > lat) && (lat >= -48)) letterDesignator = 'G'; else if ((-48 > lat) && (lat >= -56)) letterDesignator = 'F'; else if ((-56 > lat) && (lat >= -64)) letterDesignator = 'E'; else if ((-64 > lat) && (lat >= -72)) letterDesignator = 'D'; else if ((-72 > lat) && (lat >= -80)) letterDesignator = 'C'; else letterDesignator = 'Z'; return letterDesignator; }; function findSet(zoneNum) { zoneNum = parseInt(zoneNum); zoneNum = zoneNum % 6; switch (zoneNum) { case 0: return 6; break; case 1: return 1; break; case 2: return 2; break; case 3: return 3; break; case 4: return 4; break; case 5: return 5; break; default: return -1; break; } }; function findGridLetters(zoneNum, northing, easting) { zoneNum = parseInt(zoneNum); northing = parseFloat(northing); easting = parseFloat(easting); row = 1; oY = Math.round(northing); while (oY >= BLOCK_SIZE) { oY = oY - BLOCK_SIZE; row++; } row = row % GRIDSQUARE_SET_ROW_SIZE; col = 0; pO = Math.round(easting); while (pO >= BLOCK_SIZE) { pO = pO - BLOCK_SIZE; col++; } col = col % GRIDSQUARE_SET_COL_SIZE; return lettersHelper(findSet(zoneNum), row, col); }; function lettersHelper(set, row, col) { if (row == 0) { row = GRIDSQUARE_SET_ROW_SIZE - 1; } else { row--; } if (col == 0) { col = GRIDSQUARE_SET_COL_SIZE - 1; } else { col--; } switch (set) { case 1: l1 = "ABCDEFGH"; l2 = "ABCDEFGHJKLMNPQRSTUV"; return l1.charAt(col) + l2.charAt(row); break; case 2: l1 = "JKLMNPQR"; l2 = "FGHJKLMNPQRSTUVABCDE"; return l1.charAt(col) + l2.charAt(row); break; case 3: l1 = "STUVWXYZ"; l2 = "ABCDEFGHJKLMNPQRSTUV"; return l1.charAt(col) + l2.charAt(row); break; case 4: l1 = "ABCDEFGH"; l2 = "FGHJKLMNPQRSTUVABCDE"; return l1.charAt(col) + l2.charAt(row); break; case 5: l1 = "JKLMNPQR"; l2 = "ABCDEFGHJKLMNPQRSTUV"; return l1.charAt(col) + l2.charAt(row); break; case 6: l1 = "STUVWXYZ"; l2 = "FGHJKLMNPQRSTUVABCDE"; return l1.charAt(col) + l2.charAt(row); break; } }; function UTMtoLL(UTMNorthing, UTMEasting, UTMZoneNumber, ret) { var xUTM = parseFloat(UTMEasting) - EASTING_OFFSET; var yUTM = parseFloat(UTMNorthing); var zoneNumber = parseInt(UTMZoneNumber); var lonOrigin = (zoneNumber - 1) * 6 - 180 + 3; var M = yUTM / k0; var mu = M / (EQUATORIAL_RADIUS * (1 - ECC_SQUARED / 4 - 3 * ECC_SQUARED * ECC_SQUARED / 64 - 5 * ECC_SQUARED * ECC_SQUARED * ECC_SQUARED / 256)); var phi1Rad = mu + (3 * E1 / 2 - 27 * E1 * E1 * E1 / 32) * Math.sin(2 * mu) + (21 * E1 * E1 / 16 - 55 * E1 * E1 * E1 * E1 / 32) * Math.sin(4 * mu) + (151 * E1 * E1 * E1 / 96) * Math.sin(6 * mu); var phi1 = phi1Rad * RAD_2_DEG; var N1 = EQUATORIAL_RADIUS / Math.sqrt(1 - ECC_SQUARED * Math.sin(phi1Rad) * Math.sin(phi1Rad)); var T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad); var C1 = ECC_PRIME_SQUARED * Math.cos(phi1Rad) * Math.cos(phi1Rad); var R1 = EQUATORIAL_RADIUS * (1 - ECC_SQUARED) / Math.pow(1 - ECC_SQUARED * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5); var D = xUTM / (N1 * k0); var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * ECC_PRIME_SQUARED) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * ECC_PRIME_SQUARED - 3 * C1 * C1) * D * D * D * D * D * D / 720); lat = lat * RAD_2_DEG; var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * ECC_PRIME_SQUARED + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad); lon = lonOrigin + lon * RAD_2_DEG; ret.lat = lat; ret.lon = lon; dL.lat = lat; dL.lng = lon; return; }; var UTMGzdLetters = "NPQRSTUVWX"; var USNGSqEast = "ABCDEFGHJKLMNPQRSTUVWXYZ"; var USNGSqLetOdd = "ABCDEFGHJKLMNPQRSTUV"; var USNGSqLetEven = "FGHJKLMNPQRSTUVABCDE"; function USNGtoUTM(bd, let, sq1, sq2, east, north, ret) { var zoneBase = [1.1, 2.0, 2.9, 3.8, 4.7, 5.6, 6.5, 7.3, 8.2, 9.1, 0, 0.8, 1.7, 2.6, 3.5, 4.4, 5.3, 6.2, 7.0, 7.9]; var segBase = [0, 2, 2, 2, 4, 4, 6, 6, 8, 8, 0, 0, 0, 2, 2, 4, 4, 6, 6, 6]; var eSqrs = USNGSqEast.indexOf(sq1); var appxEast = 1 + eSqrs % 8; var letNorth = "CDEFGHJKLMNPQRSTUVWX".indexOf(let); if (bd % 2) var nSqrs = "ABCDEFGHJKLMNPQRSTUV".indexOf(sq2); else var nSqrs = "FGHJKLMNPQRSTUVABCDE".indexOf(sq2); var zoneStart = zoneBase[letNorth]; var appxNorth = Number(segBase[letNorth]) + nSqrs / 10; if (appxNorth < zoneStart) appxNorth += 2; ret.N = appxNorth * 1000000 + Number(north) * Math.pow(10, 5 - north.length); ret.E = appxEast * 100000 + Number(east) * Math.pow(10, 5 - east.length); ret.bd = bd; ret.letter = let; return; }; function USNGtoLL() { usngStr_input = dL.cz; var usngp = new Object(); parseUSNG_str(usngStr_input, usngp); var coords = new Object(); USNGtoUTM(usngp.bd, usngp.let, usngp.sq1, usngp.sq2, usngp.east, usngp.north, coords); if (usngp.let < 'N') { coords.N -= NORTHING_OFFSET } UTMtoLL(coords.N, coords.E, usngp.bd, coords); dL.lat = coords.lat; dL.lng = coords.lon; }; function parseUSNG_str(usngStr_input, parts) { var j = 0; var k; var usngStr = []; var usngStr_temp = []; usngStr_temp = usngStr_input.toUpperCase(); var regexp = /%20/g; usngStr = usngStr_temp.replace(regexp, ""); regexp = / /g; usngStr = usngStr_temp.replace(regexp, ""); if (usngStr.length < 7) { Console.log("This application requires minimum USNG precision of 10,000 meters.  From USNG conversion code."); return 0; } if (isNaN(parseInt(usngStr.substr(1, 1)))) { parts.bd = usngStr.charAt(j++) * 1; } else { parts.bd = usngStr.charAt(j++) * 10 + usngStr.charAt(j++) * 1; } parts.let = usngStr.charAt(j++); parts.sq1 = usngStr.charAt(j++); parts.sq2 = usngStr.charAt(j++); parts.precision = (usngStr.length - j) / 2; parts.east = ''; parts.north = ''; for (var k = 0; k < parts.precision; k++) { parts.east += usngStr.charAt(j++) } if (usngStr[j] == " ") { j++ } for (var k = 0; k < parts.precision; k++) { parts.north += usngStr.charAt(j++) } }; function isUSNG(inputStr) { var j = 0; var k; var usngStr = []; var strregexp; usngStr = inputStr.toUpperCase(); var regexp = /%20/g; usngStr = usngStr.replace(regexp, ""); regexp = / /g; usngStr = usngStr.replace(regexp, ""); if (usngStr.length > 15) { return 0; } strregexp = new RegExp("^[0-9]{2}[CDEFGHJKLMNPQRSTUVWX]$"); if (usngStr.match(strregexp)) { Console.log("Input appears to be a UTM bd...more precision is required to display a correct result.  From USNG conversion code."); return 0; } strregexp = new RegExp("^[0-9]{2}[CDEFGHJKLMNPQRSTUVWX][ABCDEFGHJKLMNPQRSTUVWXYZ][ABCDEFGHJKLMNPQRSTUV]([0-9][0-9]){0,5}$"); if (!usngStr.match(strregexp)) { return 0; } if (usngStr.length < 7) { Console.log(usngStr + " Appears to be a USNG string, but this application requires precision of at least 10,000 meters.  From USNG conversion code."); return 0; } return usngStr; }; function LLtoMGRS(lat, lon, precision) { var sU = ""; var nQ = LLtoUSNG(lat, lon, precision); var regexp = / /g; sU = nQ.replace(regexp, ""); return (sU); }; function LLtoUSNG_nad27(lat, lon, precision) { var usngstr; EQUATORIAL_RADIUS = 6378206.4; ECC_SQUARED = 0.006768658; usngstr = LLtoUSNG(lat, lon, precision); EQUATORIAL_RADIUS = 6378137.0; ECC_SQUARED = 0.006694380023; return usngstr + " (NAD27)"; } 